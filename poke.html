<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>神秘扭蛋機 - 寶可夢限定版</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&family=Noto+Sans+TC:wght@700;900&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>

    <style>
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000; 
            font-family: 'Chakra Petch', 'Noto Sans TC', sans-serif;
            -webkit-font-smoothing: antialiased;
        }

        /* --- UI STYLES --- */
        .bg-media {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            transition: opacity 0.5s ease;
        }
        #bgVideo { display: none; }
        #renderCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
            cursor: default; 
            background: transparent; 
            z-index: 1;
            opacity: 0; 
            transition: opacity 1s ease;
        }
        .glitch-wrapper {
            position: absolute;
            top: 0; 
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none; 
        }
        .glitch-text {
            font-size: 4.5rem;
            font-weight: 900;
            color: #fbbf24;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            position: relative;
            text-shadow: 3px 3px 0px #b91c1c, -3px -3px 0px #2563eb;
            animation: glitch-skew 4s infinite linear alternate-reverse;
            font-family: 'Noto Sans TC', sans-serif;
        }
        .system-msg-container {
            position: absolute;
            top: 15%; 
            width: 100%;
            text-align: center;
            pointer-events: none;
        }
        .system-msg {
            font-size: 2rem;
            color: #ef4444; 
            text-shadow: 2px 2px 0px #7f1d1d;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .glitch-name { animation: glitch-skew 3s infinite linear alternate-reverse; }
        #refillBtn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 30;
            padding: 1.5rem 4rem;
            font-size: 2rem;
            background: rgba(220, 38, 38, 0.95);
            color: white;
            border: 2px solid #fecaca;
            border-radius: 0.5rem;
            font-family: 'Noto Sans TC', sans-serif;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 0 30px rgba(220, 38, 38, 0.6);
            cursor: pointer;
            transition: all 0.2s ease;
            display: none; /* 預設隱藏，程式控制顯示 */
        }
        #refillBtn:hover {
            background: rgba(185, 28, 28, 1);
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 50px rgba(220, 38, 38, 0.9);
        }
        @keyframes glitch-skew {
            0% { transform: skew(0deg); }
            20% { transform: skew(0deg); }
            21% { transform: skew(-10deg); filter: blur(2px); }
            22% { transform: skew(10deg); filter: blur(0px); }
            23% { transform: skew(0deg); }
            60% { transform: skew(0deg); }
            61% { transform: skew(5deg); opacity: 0.8; }
            62% { transform: skew(0deg); opacity: 1; }
            100% { transform: skew(0deg); }
        }
        
        @media (max-width: 768px) {
            .glitch-text { font-size: 2.5rem; letter-spacing: 0.1em; }
            .system-msg { 
                font-size: 1.2rem !important; 
                text-shadow: 1px 1px 0px #7f1d1d;
            }
        }
        
        #flashScreen {
            pointer-events: none;
            z-index: 45;
        }
        .flash-active { animation: flashAnim 0.8s ease-out forwards; }
        @keyframes flashAnim {
            0% { opacity: 0; }
            40% { opacity: 1; }
            100% { opacity: 0; }
        }
        .overlay-hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(1.1);
        }
        .overlay-visible {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
        }
        .btn-container {
            position: relative;
            padding: 4px; 
            background: linear-gradient(180deg, #b45309 0%, #78350f 100%); 
            border-radius: 0.75rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            transition: transform 0.1s ease;
            z-index: 60;
        }
        .btn-container:active { transform: scale(0.96); }
        .btn-3a {
            position: relative;
            padding: 1.2rem 4rem;
            font-size: 2rem;
            font-weight: 700;
            color: #422006; 
            background: linear-gradient(to bottom, #fde68a 0%, #f59e0b 50%, #d97706 100%);
            border: 2px solid #fef3c7; 
            border-radius: 0.5rem;
            outline: none;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            text-shadow: 0px 1px 0px rgba(255,255,255,0.4);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.2);
            font-family: 'Noto Sans TC', sans-serif;
        }
        .btn-3a::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(120deg, transparent 30%, rgba(255,255,255,0.6) 50%, transparent 70%);
            background-size: 200% 100%;
            background-repeat: no-repeat;
            background-position: 150% 0;
            animation: sheen 5s infinite;
            mix-blend-mode: overlay;
        }
        .btn-deco {
            position: absolute;
            width: 8px; height: 8px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 5px #fcd34d;
            z-index: 10;
        }
        .bd-tl { top: 8px; left: 8px; }
        .bd-tr { top: 8px; right: 8px; }
        .bd-bl { bottom: 8px; left: 8px; }
        .bd-br { bottom: 8px; right: 8px; }
        @keyframes sheen {
            0% { background-position: 150% 0; }
            40% { background-position: -50% 0; }
            100% { background-position: -50% 0; }
        }
        @keyframes shine {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }
        
        /* --- ANIMATIONS --- */
        @keyframes zoomInBreathe {
            0% { transform: scale(0); opacity: 0; filter: url(#poke-3d-effect) brightness(1) saturate(1.8); }
            50% { transform: scale(1.2); opacity: 1; filter: url(#poke-3d-effect) brightness(1) saturate(1.8); }
            100% { transform: scale(1); opacity: 1; filter: url(#poke-3d-effect) brightness(1) saturate(1.8); }
        }
        @keyframes breathe {
            0% { transform: scale(1); filter: url(#poke-3d-effect) brightness(1) saturate(1.8); }
            50% { transform: scale(1.05); filter: url(#poke-3d-effect) brightness(1) saturate(1.8); }
            100% { transform: scale(1); filter: url(#poke-3d-effect) brightness(1) saturate(1.8); }
        }
        .anim-reveal {
            animation: zoomInBreathe 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                       breathe 4s ease-in-out infinite 0.6s; 
            z-index: 100; 
            position: relative; 
            transform-style: preserve-3d;
        }

        @keyframes raysRotatePulse {
            0% { transform: translate(-50%, -50%) rotate(0deg); opacity: 0.8; }
            50% { opacity: 1.0; }
            100% { transform: translate(-50%, -50%) rotate(360deg); opacity: 0.8; }
        }
        .god-rays {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200vmax;
            height: 200vmax;
            background: conic-gradient(from 0deg, transparent 0%, rgba(255, 215, 0, 0.5) 10%, transparent 20%, rgba(255, 215, 0, 0.5) 30%, transparent 40%, rgba(255, 215, 0, 0.5) 50%, transparent 60%, rgba(255, 215, 0, 0.5) 70%, transparent 80%, rgba(255, 215, 0, 0.5) 90%, transparent 100%);
            animation: raysRotatePulse 20s linear infinite;
            z-index: 0; 
            pointer-events: none;
            mix-blend-mode: screen; 
        }
        .text-outline {
            text-shadow: -2px -2px 0 #422006, 2px -2px 0 #422006, -2px 2px 0 #422006, 2px 2px 0 #422006, 3px 3px 5px rgba(0,0,0,0.5);
            font-family: 'Noto Sans TC', sans-serif;
        }
        .custom-backdrop {
            backdrop-filter: blur(5px);
            background-color: rgba(0,0,0,0.7);
        }
        .reward-content { position: relative; z-index: 50; }
        .image-wrapper { position: relative; z-index: 60; perspective: 1000px; }

        .title-container {
            position: absolute;
            top: 0;
            left: 0;
            transform: translate(-50%, -100%); 
            width: 200px; 
            pointer-events: none; 
            z-index: 10;
            animation: simple-breathe 3s infinite alternate ease-in-out;
            transform-origin: center bottom;
        }

        .title-img {
            width: 100%;
            height: auto;
            display: block;
        }

        @keyframes simple-breathe {
            0% { 
                filter: drop-shadow(0 0 5px rgba(251, 191, 36, 0.5)) saturate(1);
            }
            100% { 
                filter: drop-shadow(0 0 30px rgba(251, 191, 36, 2.5)) saturate(1.3);
            }
        }

        @media (max-height: 600px) and (orientation: landscape) {
            .reward-content { 
                padding: 0.5rem !important; 
                transform: scale(1.2);
                transform-origin: center center;
            }
            .image-wrapper { 
                width: 120px !important; 
                height: 120px !important; 
                margin-bottom: 0.25rem !important; 
            }
            #englishName { 
                font-size: 1.2rem !important; 
                margin-bottom: 0.25rem !important; 
            }
            #rewardName { 
                font-size: 2rem !important; 
                margin-bottom: 0.5rem !important; 
            }
            .btn-3a { 
                padding: 0.8rem 2.5rem !important; 
                font-size: 1.2rem !important; 
            }
        }
        
        .mobile-controls {
            display: none; 
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 35;
            gap: 15px;
            pointer-events: auto;
        }

        @media (max-width: 1024px) {
            .mobile-controls {
                display: flex;
            }
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
            padding: 8px 16px;
            font-size: 0.9rem;
            font-family: 'Noto Sans TC', sans-serif;
            font-weight: normal;
            border-radius: 8px;
            backdrop-filter: blur(2px);
            box-shadow: none;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.3);
            color: #fff;
            transform: scale(0.95);
        }

        .overlay-visible ~ .mobile-controls {
            display: none;
        }
    </style>
</head>
<body>

    <img id="bgImg" src="https://misterp8.github.io/Gachapon/images/bk.jpg" class="bg-media">
    <video id="bgVideo" class="bg-media" muted loop playsinline>
        <source src="https://misterp8.github.io/Gachapon/images/bk.mp4" type="video/mp4">
    </video>

    <svg width="0" height="0" style="position: absolute; pointer-events: none;">
        <defs>
            <filter id="poke-3d-effect" x="-20%" y="-20%" width="140%" height="140%">
                <feTurbulence type="fractalNoise" baseFrequency="0.015" numOctaves="2" result="noise" seed="5">
                    <animate attributeName="baseFrequency" values="0.015;0.01;0.015" dur="4s" repeatCount="indefinite" />
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="8" xChannelSelector="R" yChannelSelector="G" result="distorted" />
            </filter>
        </defs>
    </svg>

    <canvas id="renderCanvas"></canvas>

    <div id="flashScreen" class="fixed inset-0 bg-white opacity-0"></div>

    <div id="loadingScreen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black text-white transition-opacity duration-1000">
        <div class="text-2xl md:text-4xl font-bold mb-4 glitch-text" style="position:relative; top:0;">系統啟動中</div>
        <div class="w-64 h-2 bg-gray-800 rounded overflow-hidden relative">
            <div id="loadingBar" class="h-full bg-yellow-500 w-0 transition-all duration-100 ease-out"></div>
        </div>
        <div class="mt-4 flex justify-between w-64 text-sm font-mono text-yellow-500">
            <span id="loadingStatus">初始化模組...</span>
            <span id="loadingPercent">0%</span>
        </div>
    </div>

    <div class="glitch-wrapper">
        <div class="title-container">
            <img src="https://misterp8.github.io/Gachapon/images/tittle.png" class="title-img" alt="神秘扭蛋機">
        </div>
        
        <div class="system-msg-container">
            <div id="systemMessage" class="system-msg glitch-text"></div>
        </div>
    </div>

    <div class="mobile-controls">
        <button id="btnToggleBg" class="control-btn">背景</button>
    </div>

    <button id="refillBtn">補充滿滿的扭蛋</button>

    <div id="rewardOverlay" class="fixed inset-0 z-40 flex items-center justify-center custom-backdrop transition-all duration-500 overlay-hidden">
        <div class="god-rays"></div>
        <div class="reward-content flex flex-col items-center max-w-lg w-full p-8">
            <div id="englishName" class="text-3xl md:text-5xl font-bold text-yellow-400 mb-4 tracking-widest font-mono glitch-name text-outline">
                POKEMON
            </div>
            <div class="image-wrapper relative w-64 h-64 md:w-80 md:h-80 mb-6 group">
                <div class="absolute inset-0 bg-gradient-to-r from-yellow-300 to-pink-500 rounded-full blur-xl opacity-75 animate-pulse" style="z-index:-1;"></div>
                <img id="rewardImage" src="" alt="Reward" class="relative w-full h-full object-contain">
            </div>

            <h2 id="rewardName" class="text-5xl md:text-6xl font-black text-yellow-400 tracking-tighter drop-shadow-lg mb-8 text-center uppercase text-outline" style="animation: shine 3s linear infinite;">
                ？？？
            </h2>

            <div class="btn-container">
                <div class="btn-deco bd-tl"></div>
                <div class="btn-deco bd-tr"></div>
                <button id="playAgainBtn" class="btn-3a">
                    再玩一次
                </button>
                <div class="btn-deco bd-bl"></div>
                <div class="btn-deco bd-br"></div>
            </div>
        </div>
    </div>

    <script>
        // --- DATA SETS ---
        const POKEMON_DATA = [
{name:"皮卡丘 (Pikachu)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/025.png"},
{name:"伊布 (Eevee)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/133.png"},
{name:"噴火龍 (Charizard)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/006.png"},
{name:"夢幻 (Mew)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/151.png"},
{name:"超夢 (Mewtwo)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/150.png"},
{name:"阿爾宙斯 (Arceus)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/493.png"},
{name:"烈空坐 (Rayquaza)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/384.png"},
{name:"桃歹郎 (Pecharunt)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1025.png"},
{name:"薩戮德 (Zarude)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/893.png"},
{name:"捷拉奧拉 (Zeraora)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/807.png"},
{name:"瑪夏多 (Marshadow)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/802.png"},
{name:"美錄坦 (Meltan)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/808.png"},
{name:"美錄梅塔 (Melmetal)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/809.png"},
{name:"蒂安希 (Diancie)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/719.png"},
{name:"胡帕 (Hoopa)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/720.png"},
{name:"波爾凱尼恩 (Volcanion)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/721.png"},
{name:"瑪機雅娜 (Magearna)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/801.png"},
{name:"維克蒂尼 (Victini)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/494.png"},
{name:"蓋諾賽克特 (Genesect)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/649.png"},
{name:"美洛耶塔 (Meloetta)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/648.png"},
{name:"凱路迪歐 (Keldeo)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/647.png"},
{name:"謝米 (Shaymin)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/492.png"},
{name:"達克萊伊 (Darkrai)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/491.png"},
{name:"瑪納霏 (Manaphy)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/490.png"},
{name:"基拉祈 (Jirachi)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/385.png"},
{name:"代歐奇希斯 (Deoxys)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/386.png"},
{name:"雪拉比 (Celebi)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/251.png"},
{name:"太樂巴戈斯 (Terapagos)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1024.png"},
{name:"故勒頓 (Koraidon)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1007.png"},
{name:"密勒頓 (Miraidon)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1008.png"},
{name:"蒼響 (Zacian)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/888.png"},
{name:"藏瑪然特 (Zamazenta)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/889.png"},
{name:"無極汰那 (Eternatus)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/890.png"},
{name:"奈克洛茲瑪 (Necrozma)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/800.png"},
{name:"索爾迦雷歐 (Solgaleo)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/791.png"},
{name:"露奈雅拉 (Lunala)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/792.png"},
{name:"哲爾尼亞斯 (Xerneas)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/716.png"},
{name:"伊裴爾塔爾 (Yveltal)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/717.png"},
{name:"基格爾德 (Zygarde)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/718.png"},
{name:"萊希拉姆 (Reshiram)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/643.png"},
{name:"捷克羅姆 (Zekrom)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/644.png"},
{name:"酋雷姆 (Kyurem)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/646.png"},
{name:"帝牙盧卡 (Dialga)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/483.png"},
{name:"帕路奇亞 (Palkia)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/484.png"},
{name:"騎拉帝納 (Giratina)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/487.png"},
{name:"固拉多 (Groudon)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/383.png"},
{name:"蓋歐卡 (Kyogre)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/382.png"},
{name:"鳳王 (Ho-Oh)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/250.png"},
{name:"洛奇亞 (Lugia)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/249.png"},
{name:"厄鬼椪 (Ogerpon)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1017.png"},
{name:"古劍豹 (Chien-Pao)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1002.png"},
{name:"古鼎鹿 (Ting-Lu)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1003.png"},
{name:"古玉魚 (Chi-Yu)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1004.png"},
{name:"古簡蝸 (Wo-Chien)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1001.png"},
{name:"夠讚狗 (Okidogi)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1014.png"},
{name:"願增猿 (Munkidori)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1015.png"},
{name:"吉雉雞 (Fezandipiti)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1016.png"},
{name:"蕾冠王 (Calyrex)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/898.png"},
{name:"雪暴馬 (Glastrier)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/896.png"},
{name:"靈幽馬 (Spectrier)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/897.png"},
{name:"眷戀雲 (Enamorus)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/905.png"},
{name:"武道熊師 (Urshifu)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/892.png"},
{name:"銀伴戰獸 (Silvally)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/773.png"},
{name:"轟鳴月 (Roaring Moon)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1005.png"},
{name:"鐵武者 (Iron Valiant)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1006.png"},
{name:"波蕩水 (Walking Wake)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1009.png"},
{name:"鐵斑葉 (Iron Leaves)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1010.png"},
{name:"破空焰 (Gouging Fire)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1020.png"},
{name:"猛雷鼓 (Raging Bolt)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1021.png"},
{name:"鐵磐岩 (Iron Boulder)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1022.png"},
{name:"鐵頭殼 (Iron Crown)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1023.png"},
{name:"虛吾伊德 (Nihilego)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/793.png"},
{name:"費洛美螳螂 (Pheromosa)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/795.png"},
{name:"爆肌蚊 (Buzzwole)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/794.png"},
{name:"鐵火輝夜 (Celesteela)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/797.png"},
{name:"紙御劍 (Kartana)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/798.png"},
{name:"惡食大王 (Guzzlord)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/799.png"},
{name:"四顎針龍 (Naganadel)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/804.png"},
{name:"戟脊龍 (Baxcalibur)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/998.png"},
{name:"多龍巴魯托 (Dragapult)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/887.png"},
{name:"杖尾鱗甲龍 (Kommo-o)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/784.png"},
{name:"黏美龍 (Goodra)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/706.png"},
{name:"三首惡龍 (Hydreigon)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/635.png"},
{name:"烈咬陸鯊 (Garchomp)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/445.png"},
{name:"巨金怪 (Metagross)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/376.png"},
{name:"暴飛龍 (Salamence)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/373.png"},
{name:"班基拉斯 (Tyranitar)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/248.png"},
{name:"快龍 (Dragonite)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/149.png"},
{name:"索財靈 (Gimmighoul)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/999.png"},
{name:"賽富豪 (Gholdengo)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/1000.png"},
{name:"仙子伊布 (Sylveon)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/700.png"},
{name:"謎擬Q (Mimikyu)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/778.png"},
{name:"路卡利歐 (Lucario)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/448.png"},
{name:"甲賀忍蛙 (Greninja)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/658.png"},
{name:"耿鬼 (Gengar)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/094.png"},
{name:"沙奈朵 (Gardevoir)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/282.png"},
{name:"索羅亞克 (Zoroark)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/571.png"},
{name:"古空棘魚 (Relicanth)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/369.png"},
{name:"象徵鳥 (Sigilyph)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/561.png"},
{name:"帕奇利茲 (Pachirisu)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/417.png"},
{name:"聒噪鳥 (Chatot)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/441.png"},
{name:"尖牙籠 (Carnivine)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/455.png"},
{name:"摔角鷹人 (Hawlucha)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/701.png"},
{name:"鑰圈兒 (Klefki)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/707.png"},
{name:"花療環環 (Comfey)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/764.png"},
{name:"花舞鳥 (Oricorio)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/741.png"},
{name:"燃燒蟲 (Larvesta)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/636.png"},
{name:"火神蛾 (Volcarona)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/637.png"},
{name:"夜盜火蜥 (Salandit)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/757.png"},
{name:"焰后蜥 (Salazzle)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/758.png"},
{name:"涼脊龍 (Frigibax)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/996.png"},
{name:"炭小侍 (Charcadet)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/935.png"},
{name:"蒼炎刃鬼 (Ceruledge)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/937.png"},
{name:"紅蓮鎧騎 (Armarouge)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/936.png"},
{name:"海地鼠 (Wiglett)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/960.png"},
{name:"噗隆隆 (Varoom)",url:"https://assets.pokemon.com/assets/cms2/img/pokedex/detail/965.png"}
        ];

        // ★★★ GAME CONFIGURATION (MODES) - POKEMON Only ★★★
        const GAME_MODES = {
            POKEMON: {
                id: 'POKEMON',
                name: "寶可夢扭蛋",
                data: POKEMON_DATA,
                ui: {
                    showText: true, 
                    animClass: "anim-reveal" 
                },
                capsule: {
                    hasDetails: true, 
                    matProps: { metallic: 0.3, roughness: 0.15, envIntensity: 1.2 },
                    generate: (scene, resources) => {
                        return {
                            texture: resources.pokeballTexture,
                            metadata: { type: 'POKE' }
                        };
                    },
                    exitMat: { metallic: 0.8, roughness: 0.2, envIntensity: 3.0 }
                }
            }
        };

        class GameAudio {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(this.ctx.destination);
                
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-24, this.ctx.currentTime);
                compressor.knee.setValueAtTime(30, this.ctx.currentTime);
                compressor.ratio.setValueAtTime(12, this.ctx.currentTime);
                compressor.attack.setValueAtTime(0.003, this.ctx.currentTime);
                compressor.release.setValueAtTime(0.25, this.ctx.currentTime);

                this.masterGain.disconnect();
                this.masterGain.connect(compressor);
                compressor.connect(this.ctx.destination);
                
                this.lastCollisionTime = 0;
            }

            createNoiseBuffer() {
                if(this._noiseBuffer) return this._noiseBuffer;
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
                this._noiseBuffer = buffer;
                return this._noiseBuffer;
            }

            playOsc(type, freq, startTime, duration, vol = 1.0, slideTo = null) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
                if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + startTime + duration);
                gain.gain.setValueAtTime(0, this.ctx.currentTime + startTime);
                gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + startTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + startTime + duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(this.ctx.currentTime + startTime);
                osc.stop(this.ctx.currentTime + startTime + duration);
            }

            playCollisionSound(intensity = 1.0) {
                const now = Date.now();
                if (now - this.lastCollisionTime < 80) return; 
                this.lastCollisionTime = now;
                const vol = Math.min(0.4 * intensity, 0.6);
                const freq = 300 + (Math.random() * 50); 
                this.playOsc('sine', freq, 0, 0.15, vol);
            }

            playSpinSound() {
                const now = this.ctx.currentTime;
                const clicks = 8; 
                const totalDuration = 1.0; 
                
                for (let i = 0; i < clicks; i++) {
                    const t = now + (i * (totalDuration / clicks));
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'triangle'; 
                    osc.frequency.setValueAtTime(400, t);
                    osc.frequency.exponentialRampToValueAtTime(800, t + 0.05);
                    
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.25, t + 0.01); 
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start(t);
                    osc.stop(t + 0.15);
                }
            }

            playOpenSound() {
                const t = this.ctx.currentTime;
                const thudOsc = this.ctx.createOscillator();
                const thudGain = this.ctx.createGain();
                thudOsc.frequency.setValueAtTime(150, t);
                thudOsc.frequency.exponentialRampToValueAtTime(40, t + 0.2);
                thudGain.gain.setValueAtTime(0.8, t);
                thudGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                thudOsc.connect(thudGain);
                thudGain.connect(this.masterGain);
                thudOsc.start(t);
                thudOsc.stop(t + 0.3);
                this.playOsc('triangle', 2000, 0.1, 0.1, 0.1);
            }

            playWinSound() {
                const t = this.ctx.currentTime;
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.3;
                const delayFeedback = this.ctx.createGain();
                delayFeedback.gain.value = 0.4;
                const delayMerge = this.ctx.createGain();
                delay.connect(delayFeedback);
                delayFeedback.connect(delay);
                delay.connect(delayMerge);
                delayMerge.connect(this.masterGain);
                delayMerge.connect(this.masterGain);

                [261.63, 329.63, 392.00, 523.25].forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = i % 2 === 0 ? 'triangle' : 'sine';
                    osc.frequency.value = freq;
                    const start = t + i * 0.1;
                    const dur = 2.0;
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.12, start + 0.1); 
                    gain.gain.exponentialRampToValueAtTime(0.001, start + dur);
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(delay);
                    osc.start(start);
                    osc.stop(start + dur);
                });
                
                const subOsc = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                subOsc.frequency.setValueAtTime(130, t);
                subOsc.frequency.exponentialRampToValueAtTime(65, t + 1.0);
                subGain.gain.setValueAtTime(0.3, t); 
                subGain.gain.linearRampToValueAtTime(0, t + 1.0);
                subOsc.connect(subGain);
                subGain.connect(this.masterGain);
                subOsc.start(t);
                subOsc.stop(t + 1.0);
            }
            
            playTone(freq, type, duration) {
                this.playOsc(type, freq, 0, duration, 0.5);
            }
        }

        class GachaGame {
            constructor() {
                this.canvas = document.getElementById("renderCanvas");
                this.engine = null;
                this.scene = null;
                this.assetsManager = null;
                this.audio = new GameAudio();
                
                // ★★★ Default Mode: POKEMON (Fixed) ★★★
                this.currentMode = 'POKEMON'; 
                
                this.history = new Set();
                this.maxHistory = 20;
                this.isSpinning = false;
                this.capsules = [];
                this.materials = {};
                
                this.knob = null; 
                this.knobMesh = null; 
                this.pokeballTexture = null;
                this.tempCapsule = null; 
                this.glowLayer = null;
                this.shadowGen = null;
                this.chuteDoor = null; 
                this.chuteLight = null; 
                
                this.chuteParticles = null; 
                
                this.leftLight = null;
                this.rightLight = null;
                this.orbitLights = [];
                this.pendingRewardImage = null;

                // 3D Projection Anchors
                this.titleAnchor = null;
                this.titleLeft = null;
                this.titleRight = null;

                this.envUrl = "https://assets.babylonjs.com/environments/studio.hdr";
                this.flareUrl = "https://www.babylonjs-playground.com/textures/flare.png";
                
                window.game = this;
                this.init();
            }

            async init() {
                if (navigator.gpu && BABYLON.WebGPUEngine.IsSupportedAsync) {
                     this.engine = new BABYLON.WebGPUEngine(this.canvas);
                     await this.engine.initAsync();
                } else {
                    this.engine = new BABYLON.Engine(this.canvas, true);
                }
                this.setupBasicScene();
                this.loadAssets();
                window.addEventListener("resize", () => this.engine.resize());
            }

            setupBasicScene() {
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
                
                const gravityVector = new BABYLON.Vector3(0, -20, 0);
                const physicsPlugin = new BABYLON.CannonJSPlugin(false); 
                this.scene.enablePhysics(gravityVector, physicsPlugin);
                physicsPlugin.setTimeStep(1/60);

                const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.1, 32, new BABYLON.Vector3(0, 4, 0), this.scene);
                camera.fovMode = BABYLON.Camera.FOVMODE_VERTICAL_FIXED; 
                camera.fov = 0.8;
                camera.setTarget(new BABYLON.Vector3(0, 1.2, 0));

                const adjustCameraRadius = () => {
                    const isPortrait = window.innerHeight > window.innerWidth;
                    camera.radius = isPortrait ? 40 : 32;
                };

                adjustCameraRadius();
                window.addEventListener("resize", adjustCameraRadius);

                const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), this.scene);
                hemiLight.intensity = 1.2;
                hemiLight.groundColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                hemiLight.diffuse = new BABYLON.Color3(0.4, 0.3, 0.8); 
                hemiLight.groundColor = new BABYLON.Color3(0.1, 0.0, 0.2);

                this.spotLight = new BABYLON.SpotLight("spot", new BABYLON.Vector3(0, 20, 0), new BABYLON.Vector3(0, -1, 0), Math.PI/3, 2, this.scene);
                this.spotLight.intensity = 6.0;
                this.spotLight.diffuse = new BABYLON.Color3(0.6, 0.4, 1.0);

                const frontLight = new BABYLON.DirectionalLight("frontLight", new BABYLON.Vector3(0.2, -0.2, 1), this.scene);
                frontLight.intensity = 0.5;
                this.shadowGen = new BABYLON.ShadowGenerator(1024, this.spotLight);
                this.shadowGen.useBlurExponentialShadowMap = true;
            }

            loadAssets() {
                this.assetsManager = new BABYLON.AssetsManager(this.scene);
                const loadingBar = document.getElementById("loadingBar");
                const loadingText = document.getElementById("loadingStatus");
                const loadingPercent = document.getElementById("loadingPercent");
                const flareTask = this.assetsManager.addTextureTask("flareTask", this.flareUrl);

                this.assetsManager.onProgress = (remainingCount, totalCount, lastFinishedTask) => {
                    const loaded = totalCount - remainingCount;
                    const percent = Math.floor((loaded / totalCount) * 100);
                    loadingBar.style.width = `${percent}%`;
                    loadingPercent.innerText = `${percent}%`;
                    loadingText.innerText = `載入資源: ${lastFinishedTask.name}`;
                };

                this.assetsManager.onFinish = (tasks) => {
                    loadingBar.style.width = '100%';
                    loadingPercent.innerText = '100%';
                    loadingText.innerText = '載入環境光照中...';
                    this.loadHDREnvironment();
                };
                this.assetsManager.load();
            }

            loadHDREnvironment() {
                const envUrl = "https://playground.babylonjs.com/textures/environment.env";
                const envTexture = new BABYLON.CubeTexture(envUrl, this.scene);
                this.scene.environmentTexture = envTexture;
                this.scene.environmentIntensity = 2.0;
                this.processLoadedAssets();
            }

            processLoadedAssets() {
                this.setupPipeline();
                this.createMaterials();
                this.buildMachine(this.shadowGen);
                this.createOrbitLights();
                this.createCapsules(this.shadowGen);
                this.createParticles();
                this.createChuteParticles();
                this.setupEvents();

                this.startRenderLoop();
                setTimeout(() => {
                    this.scene.executeWhenReady(() => {
                        const loadingScreen = document.getElementById("loadingScreen");
                        const canvas = document.getElementById("renderCanvas");
                        loadingScreen.classList.add("opacity-0", "pointer-events-none");
                        canvas.style.opacity = 1;
                    });
                }, 500);
            }

            setupPipeline() {
                const camera = this.scene.getCameraByName("camera");
                const pipeline = new BABYLON.DefaultRenderingPipeline("pipeline", true, this.scene, [camera]);
                pipeline.bloomEnabled = true;
                pipeline.bloomThreshold = 0.6;
                pipeline.bloomWeight = 1.0;
                pipeline.bloomKernel = 64;
                pipeline.bloomScale = 0.5;
                pipeline.glowLayerEnabled = true;
                pipeline.glowLayer.intensity = 0.5;
                pipeline.chromaticAberrationEnabled = true;
                pipeline.chromaticAberration.aberrationAmount = 8; 
                pipeline.chromaticAberration.radialIntensity = 0.5;
                pipeline.grainEnabled = true;
                pipeline.grain.intensity = 4;
                pipeline.grain.animated = true;
                pipeline.imageProcessingEnabled = true;
                pipeline.imageProcessing.toneMappingEnabled = true;
                pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
                pipeline.imageProcessing.exposure = 0.4; 
                pipeline.fxaaEnabled = true; 
                pipeline.samples = 4;
            }

            startRenderLoop() {
                this.engine.runRenderLoop(() => {
                    if (this.scene) {
                        this.scene.render();
                        this.animateScene();
                    }
                });
            }

            animateScene() {
                const time = performance.now() * 0.001;

                if (this.titleAnchor && this.scene.activeCamera) {
                    const engine = this.engine;
                    const camera = this.scene.activeCamera;
                    const viewport = camera.viewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());

                    const screenPos = BABYLON.Vector3.Project(
                        this.titleAnchor.getAbsolutePosition(),
                        BABYLON.Matrix.Identity(),
                        this.scene.getTransformMatrix(),
                        viewport
                    );

                    const screenLeft = BABYLON.Vector3.Project(
                        this.titleLeft.getAbsolutePosition(),
                        BABYLON.Matrix.Identity(),
                        this.scene.getTransformMatrix(),
                        viewport
                    );
                    const screenRight = BABYLON.Vector3.Project(
                        this.titleRight.getAbsolutePosition(),
                        BABYLON.Matrix.Identity(),
                        this.scene.getTransformMatrix(),
                        viewport
                    );

                    const projectedWidth = Math.abs(screenRight.x - screenLeft.x);

                    const titleEl = document.querySelector('.title-container');
                    if (titleEl) {
                        titleEl.style.left = `${screenPos.x}px`;
                        titleEl.style.top = `${screenPos.y}px`;
                        titleEl.style.width = `${projectedWidth * 1.05}px`; 
                    }
                }

                if (this.materials.neon) {
                    const intensity = 3.0;
                    const r = (Math.sin(time) * 0.5 + 0.5) * intensity;
                    const g = (Math.sin(time + 2) * 0.5 + 0.5) * intensity;
                    const b = (Math.sin(time + 4) * 0.5 + 0.5) * intensity;
                    this.materials.neon.emissiveColor.set(r, g, b);
                }

                const leftPulse = 1.2 + Math.sin(time * 3) * 1.0; 
                if (this.leftLight) this.leftLight.intensity = leftPulse * 3.0;

                const rightPulse = 1.2 + Math.sin(time * 2.5 + 2) * 1.0;
                if (this.rightLight) this.rightLight.intensity = rightPulse * 3.0;
                
                if (this.orbitLights.length > 0) {
                    this.orbitLights.forEach(light => {
                        const data = light.orbitData;
                        data.angle += data.speed * 0.01; 
                        light.position.x = Math.cos(data.angle) * data.radius;
                        light.position.z = Math.sin(data.angle) * data.radius;
                        light.position.y = data.baseY + Math.sin(time * 0.5 + data.pulseOffset) * 2;
                        light.intensity = 2.5 + Math.sin(time * data.pulseSpeed + data.pulseOffset) * 1.0;
                    });
                }

                if (this.materials.knobGold) {
                    if (!this.isSpinning) {
                        const glow = (Math.sin(time * 3) * 0.5 + 0.5) * 1.0; 
                        this.materials.knobGold.emissiveColor = new BABYLON.Color3(
                            0.02 + glow * 0.8, 
                            0.01 + glow * 0.2, 
                            0.0 + glow * 0.02
                        );
                    } else {
                        this.materials.knobGold.emissiveColor = new BABYLON.Color3(0.02, 0.01, 0);
                    }
                }

                if (this.scene.environmentTexture) {
                    this.scene.environmentTexture.rotationY += 0.0001; 
                }
            }

            createPokeballTexture() {
                const tex = new BABYLON.DynamicTexture("pokeTex", {width:256, height:256}, this.scene);
                const ctx = tex.getContext();
                ctx.fillStyle = "#D90429"; ctx.fillRect(0, 0, 256, 120);
                ctx.fillStyle = "#F8F9FA"; ctx.fillRect(0, 136, 256, 120);
                ctx.fillStyle = "#212529"; ctx.fillRect(0, 120, 256, 16);
                tex.update();
                return tex;
            }

            createNoiseTexture() {
                const tex = new BABYLON.DynamicTexture("noiseTex", {width:256, height:256}, this.scene);
                const ctx = tex.getContext();
                const idata = ctx.createImageData(256, 256);
                const buffer32 = new Uint32Array(idata.data.buffer);
                for (let i = 0; i < buffer32.length; i++) buffer32[i] = (Math.random() < 0.5) ? 0xff888888 : 0xffffffff;
                ctx.putImageData(idata, 0, 0);
                tex.update();
                return tex;
            }

            createMaterials() {
                this.pokeballTexture = this.createPokeballTexture();

                const glass = new BABYLON.PBRMaterial("glass", this.scene);
                glass.alpha = 0.12;
                glass.metallic = 0.9; 
                glass.roughness = 0.12;
                glass.subSurface.isRefractionEnabled = true;
                glass.subSurface.indexOfRefraction = 1.52; 
                glass.environmentIntensity = 0.8;
                glass.albedoColor = new BABYLON.Color3(0.05, 0.05, 0.05); 
                glass.reflectivityColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                this.materials.glass = glass;

                const metalRed = new BABYLON.PBRMaterial("metalRed", this.scene);
                metalRed.metallic = 0.4; metalRed.roughness = 0.2;
                metalRed.albedoColor = new BABYLON.Color3(0.6, 0.05, 0.1);
                metalRed.bumpTexture = this.createNoiseTexture();
                metalRed.bumpTexture.level = 0.2;  
                metalRed.environmentIntensity = 0.6; 
                this.materials.body = metalRed;

                const gold = new BABYLON.PBRMaterial("gold", this.scene);
                gold.metallic = 0.3; gold.roughness = 0.18;
                gold.albedoColor = new BABYLON.Color3(1.0, 0.7, 0.2); 
                gold.bumpTexture = this.createNoiseTexture();
                gold.bumpTexture.level = 0.1; 
                gold.environmentIntensity = 1.0; 
                this.materials.gold = gold;

                const knobGold = new BABYLON.PBRMaterial("knobGold", this.scene);
                knobGold.metallic = 0.6; knobGold.roughness = 0.15;
                knobGold.albedoColor = new BABYLON.Color3(1.0, 0.7, 0.2); 
                knobGold.bumpTexture = this.createNoiseTexture();
                knobGold.environmentIntensity = 0.5;
                this.materials.knobGold = knobGold;

                const neon = new BABYLON.StandardMaterial("neon", this.scene);
                neon.emissiveColor = new BABYLON.Color3(0, 0.5, 0.5); 
                neon.disableLighting = true;
                this.materials.neon = neon;
            }

            buildMachine(shadowGen) {
                const baseHeight = 20; const baseY = -10;
                const baseOriginal = BABYLON.MeshBuilder.CreateBox("baseOrig", {width: 12, height: baseHeight, depth: 12}, this.scene);
                baseOriginal.position.y = baseY;
                const holeBox = BABYLON.MeshBuilder.CreateBox("holeBox", {width: 3.5, height: 3.5, depth: 2}, this.scene);
                holeBox.position.y = -6.2; holeBox.position.z = -6;
                const baseCSG = BABYLON.CSG.FromMesh(baseOriginal);
                const holeCSG = BABYLON.CSG.FromMesh(holeBox);
                const base = baseCSG.subtract(holeCSG).toMesh("base", this.materials.body, this.scene);
                base.receiveShadows = true;
                base.physicsImpostor = new BABYLON.PhysicsImpostor(base, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, this.scene);
                baseOriginal.dispose(); holeBox.dispose();

                const innerChamber = BABYLON.MeshBuilder.CreateBox("innerChamber", {width: 3.4, height: 3.4, depth: 3}, this.scene);
                innerChamber.position.y = -6.2; innerChamber.position.z = -4.5;
                const darkMat = new BABYLON.StandardMaterial("darkMat", this.scene);
                darkMat.diffuseColor = new BABYLON.Color3(0.02, 0.02, 0.02);
                darkMat.sideOrientation = BABYLON.Mesh.BACKSIDE; 
                innerChamber.material = darkMat;

                const glassHeight = 11; const glassY = 5.5; 
                const glassContainer = BABYLON.MeshBuilder.CreateBox("glassContainer", {width: 11, height: glassHeight, depth: 11}, this.scene);
                glassContainer.position.y = glassY; glassContainer.material = this.materials.glass;
                
                const floor = BABYLON.MeshBuilder.CreateBox("gFloor", {width: 11, height: 1, depth: 11}, this.scene);
                floor.position.y = -0.5; floor.visibility = 0;
                floor.physicsImpostor = new BABYLON.PhysicsImpostor(floor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5 }, this.scene);
                
                const wallThick = 0.5;
                const walls = [
                    {pos: new BABYLON.Vector3(0, glassY, 5.5), size: {width: 11, height: glassHeight, depth: wallThick}},
                    {pos: new BABYLON.Vector3(0, glassY, -5.5), size: {width: 11, height: glassHeight, depth: wallThick}},
                    {pos: new BABYLON.Vector3(5.5, glassY, 0), size: {width: wallThick, height: glassHeight, depth: 11}},
                    {pos: new BABYLON.Vector3(-5.5, glassY, 0), size: {width: wallThick, height: glassHeight, depth: 11}}
                ];
                walls.forEach((w, i) => {
                    const mesh = BABYLON.MeshBuilder.CreateBox("w"+i, w.size, this.scene);
                    mesh.position = w.pos; mesh.visibility = 0;
                    mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, this.scene);
                });

                const lid = BABYLON.MeshBuilder.CreateBox("lid", {width: 12.5, height: 1, depth: 12.5}, this.scene);
                lid.position.y = 11.5; lid.material = this.materials.gold;
                lid.physicsImpostor = new BABYLON.PhysicsImpostor(lid, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, this.scene);
                shadowGen.addShadowCaster(lid);

                this.titleAnchor = new BABYLON.TransformNode("titleAnchor", this.scene);
                this.titleAnchor.position = new BABYLON.Vector3(0, 11.3, 0); 

                this.titleLeft = new BABYLON.TransformNode("titleLeft", this.scene);
                this.titleLeft.position = new BABYLON.Vector3(-6, 11.3, 0);

                this.titleRight = new BABYLON.TransformNode("titleRight", this.scene);
                this.titleRight.position = new BABYLON.Vector3(6, 11.3, 0);

                this.buildKnob();

                this.chuteLight = new BABYLON.PointLight("chuteLight", new BABYLON.Vector3(0, -6.2, -5), this.scene);
                this.chuteLight.intensity = 0; this.chuteLight.range = 10;
                this.chuteLight.diffuse = new BABYLON.Color3(1, 0.9, 0.5);

                this.chuteDoor = BABYLON.MeshBuilder.CreateBox("chuteDoor", {width: 3.3, height: 3.5, depth: 0.1}, this.scene);
                this.chuteDoor.position = new BABYLON.Vector3(0, -6.1, -6.3); 
                this.chuteDoor.material = this.materials.gold;

                [[-6, -6], [6, -6], [6, 6], [-6, 6]].forEach((o) => {
                    const strip = BABYLON.MeshBuilder.CreateBox("neon_base", {width: 0.3, height: baseHeight, depth: 0.3}, this.scene);
                    strip.position.x = o[0]; strip.position.z = o[1]; strip.position.y = baseY;
                    strip.material = this.materials.neon;
                });
            }

            buildKnob() {
                const knobRoot = new BABYLON.TransformNode("knobRoot", this.scene);
                knobRoot.position = new BABYLON.Vector3(0, -2, -6.5); knobRoot.scaling.setAll(0.7);
                const knobVis = new BABYLON.TransformNode("knobVis", this.scene);
                knobVis.parent = knobRoot; knobVis.rotation.x = Math.PI / 2; 

                const kCyl = BABYLON.MeshBuilder.CreateCylinder("kCyl", {diameter: 4, height: 1, tessellation: 64}, this.scene);
                kCyl.material = this.materials.knobGold; kCyl.parent = knobVis;

                const qMarkNode = new BABYLON.TransformNode("qMark", this.scene);
                qMarkNode.parent = knobVis; qMarkNode.position.y = 0.5;
                const qDot = BABYLON.MeshBuilder.CreateSphere("qDot", {diameter: 0.7}, this.scene);
                qDot.position.z = -1.2; qDot.scaling.y = 0.5; qDot.parent = qMarkNode; qDot.material = this.materials.knobGold;
                const qStem = BABYLON.MeshBuilder.CreateBox("qStem", {height: 0.8, width: 0.5, depth: 0.5}, this.scene);
                qStem.position.z = -0.3; qStem.rotation.x = Math.PI/2; qStem.parent = qMarkNode; qStem.material = this.materials.knobGold;

                const path = [];
                for(let i = -20; i <= 200; i+=10) {
                    const rad = BABYLON.Tools.ToRadians(i);
                    path.push(new BABYLON.Vector3(Math.cos(rad) * 0.9, 0, Math.sin(rad) * 0.9 + 0.8));
                }
                const qHook = BABYLON.MeshBuilder.CreateTube("qHook", {path: path, radius: 0.25, cap: BABYLON.Mesh.CAP_ALL}, this.scene);
                qHook.rotation.x = Math.PI/2; qHook.parent = qMarkNode; qHook.material = this.materials.knobGold;

                const kBev = BABYLON.MeshBuilder.CreateTorus("kBev", {diameter: 4, thickness: 0.4, tessellation: 64}, this.scene);
                kBev.scaling.y = 0.5; kBev.position.y = 0.5; kBev.material = this.materials.knobGold; kBev.parent = knobVis;
                const kBar = BABYLON.MeshBuilder.CreateBox("kBar", {width: 5, height: 1.2, depth: 1.2}, this.scene);
                kBar.position.y = 0.6; kBar.material = this.materials.knobGold; kBar.parent = knobVis;

                [kCyl, kBev, kBar, qDot, qStem, qHook].forEach(mesh => {
                    mesh.actionManager = new BABYLON.ActionManager(this.scene);
                    mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, () => this.canvas.style.cursor = "pointer"));
                    mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOutTrigger, () => this.canvas.style.cursor = "default"));
                });
                this.knob = knobRoot;
            }

            createOrbitLights() {
                const configs = [
                    { color: new BABYLON.Color3(1.0, 0.6, 0.1), radius: 18, y: 5, speed: 0.3, pulseSpeed: 1.5, offset: 0 }, 
                    { color: new BABYLON.Color3(1.0, 0.2, 0.2), radius: 22, y: -2, speed: -0.25, pulseSpeed: 2.0, offset: 1 }, 
                    { color: new BABYLON.Color3(1.0, 0.8, 0.4), radius: 20, y: 8, speed: 0.4, pulseSpeed: 1.2, offset: 2 }, 
                    { color: new BABYLON.Color3(1.0, 0.4, 0.8), radius: 25, y: 2, speed: -0.35, pulseSpeed: 1.8, offset: 3 } 
                ];
                configs.forEach((cfg, i) => {
                    const light = new BABYLON.PointLight(`orbitLight_${i}`, new BABYLON.Vector3(cfg.radius, cfg.y, 0), this.scene);
                    light.diffuse = cfg.color; light.specular = cfg.color; 
                    light.intensity = 3.0;
                    light.range = 60; 
                    light.orbitData = { angle: (Math.PI * 2 / configs.length) * i, radius: cfg.radius, baseY: cfg.y, speed: cfg.speed, pulseSpeed: cfg.pulseSpeed, pulseOffset: cfg.offset };
                    this.orbitLights.push(light);
                });
                
                this.leftLight = new BABYLON.PointLight("leftLight", new BABYLON.Vector3(-12, 5, -12), this.scene);
                this.leftLight.diffuse = new BABYLON.Color3(0.8, 0.4, 0.1); 
                this.leftLight.intensity = 3.5; this.leftLight.range = 50;
                
                this.rightLight = new BABYLON.PointLight("rightLight", new BABYLON.Vector3(12, 5, -12), this.scene);
                this.rightLight.diffuse = new BABYLON.Color3(1.0, 0.9, 0.6); 
                this.rightLight.intensity = 3.5; this.rightLight.range = 50;
            }

            createParticles() {
                const p1 = new BABYLON.ParticleSystem("internalP", 1000, this.scene);
                p1.particleTexture = new BABYLON.Texture(this.flareUrl, this.scene);
                p1.emitter = new BABYLON.Vector3(0, 5, 0);
                p1.minEmitBox = new BABYLON.Vector3(-5, -4, -5); p1.maxEmitBox = new BABYLON.Vector3(5, 5, 5);
                p1.color1 = new BABYLON.Color4(1, 0.9, 0.5, 0.8); 
                p1.color2 = new BABYLON.Color4(1, 0.6, 0.1, 0.2); 
                p1.minSize = 0.1; p1.maxSize = 0.3; p1.emitRate = 100; p1.start();

                const p2 = new BABYLON.ParticleSystem("bgP", 1500, this.scene);
                p2.particleTexture = new BABYLON.Texture(this.flareUrl, this.scene);
                p2.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
                p2.emitter = new BABYLON.Vector3(0, 0, 20); 
                p2.minEmitBox = new BABYLON.Vector3(-50, -40, 0); p2.maxEmitBox = new BABYLON.Vector3(50, 50, 0);
                p2.color1 = new BABYLON.Color4(0.6, 0.3, 1.0, 1.0); 
                p2.color2 = new BABYLON.Color4(0.8, 0.5, 1.0, 0.0); 
                p2.minSize = 1.0; p2.maxSize = 3.0; p2.emitRate = 50;
                p2.direction1 = new BABYLON.Vector3(-0.5, 0.5, 0); p2.direction2 = new BABYLON.Vector3(0.5, -0.5, 0);
                p2.gravity = new BABYLON.Vector3(0, 0.01, 0);
                p2.renderingGroupId = 0; 
                p2.start();
            }

            createChuteParticles() {
                const ps = new BABYLON.ParticleSystem("chuteMist", 800, this.scene);
                ps.particleTexture = new BABYLON.Texture(this.flareUrl, this.scene);
                ps.emitter = new BABYLON.Vector3(0, -7.0, -6.0); 
                ps.minEmitBox = new BABYLON.Vector3(-2, 0, 0); ps.maxEmitBox = new BABYLON.Vector3(2, 2.0, 0);
                ps.color1 = new BABYLON.Color4(0.6, 0.2, 1.0, 1.0); 
                ps.color2 = new BABYLON.Color4(0.2, 0.6, 1.0, 0.0);
                ps.minSize = 0.3; ps.maxSize = 0.8;
                ps.minLifeTime = 0.5; ps.maxLifeTime = 1.0;
                ps.emitRate = 600; ps.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
                ps.gravity = new BABYLON.Vector3(0, 2, 0); 
                ps.direction1 = new BABYLON.Vector3(-1, 2, -1); ps.direction2 = new BABYLON.Vector3(1, 2, -2); 
                ps.minAngularSpeed = 0; ps.maxAngularSpeed = Math.PI; ps.speed = 1.5;
                this.chuteParticles = ps;
            }

            createCapsules(shadowGen) {
                const floorMesh = this.scene.getMeshByName("gFloor");
                const config = GAME_MODES[this.currentMode].capsule; 

                for (let i = 0; i < 20; i++) {
                    const capsule = BABYLON.MeshBuilder.CreateSphere("cap_" + Date.now() + "_" + i, {diameter: 2.5}, this.scene);
                    
                    const genData = config.generate(this.scene, { pokeballTexture: this.pokeballTexture });
                    capsule.metadata = genData.metadata;

                    const mat = new BABYLON.PBRMaterial("capMat_" + i, this.scene);
                    mat.albedoTexture = genData.texture;
                    mat.metallic = config.matProps.metallic;
                    mat.roughness = config.matProps.roughness;
                    mat.environmentIntensity = config.matProps.envIntensity;
                    capsule.material = mat;

                    capsule.position = new BABYLON.Vector3((Math.random() - 0.5) * 9, 2 + Math.random() * 6, (Math.random() - 0.5) * 9);
                    capsule.rotation = new BABYLON.Vector3(Math.random()*Math.PI, 0, Math.random()*Math.PI);
                    
                    capsule.physicsImpostor = new BABYLON.PhysicsImpostor(capsule, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.6, friction: 0.5 }, this.scene);
                    shadowGen.addShadowCaster(capsule);
                    this.capsules.push(capsule);

                    const collideList = [];
                    if (floorMesh && floorMesh.physicsImpostor) collideList.push(floorMesh.physicsImpostor);
                    this.capsules.forEach(c => {
                        if (c !== capsule && c.physicsImpostor) collideList.push(c.physicsImpostor);
                    });

                    capsule.physicsImpostor.registerOnPhysicsCollide(collideList, (main, collided) => {
                        const v = main.getLinearVelocity();
                        if (v && v.length() > 3.0) this.audio.playCollisionSound();
                    });
                }
            }

            toggleBackground() {
                const vid = document.getElementById("bgVideo");
                const img = document.getElementById("bgImg");
                if (getComputedStyle(vid).display !== 'none') {
                    vid.style.display = "none"; vid.pause(); img.style.display = "block";
                } else {
                    vid.style.display = "block"; vid.play().catch(console.error); img.style.display = "none";
                }
            }

            setupEvents() {
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'v') {
                        this.toggleBackground();
                    }
                    // Removed 'm' menu key binding
                });

                const btnBg = document.getElementById("btnToggleBg");
                if(btnBg) {
                    btnBg.addEventListener("click", (e) => {
                        e.stopPropagation(); 
                        if (navigator.vibrate) navigator.vibrate(50); 
                        this.toggleBackground();
                    });
                }

                // Removed btnToggleMenu event listener

                const refillBtn = document.getElementById("refillBtn");
                refillBtn.addEventListener("click", () => {
                    refillBtn.style.display = "none";
                    this.refillCapsules();
                });

                document.getElementById("playAgainBtn").addEventListener("click", () => {
                    document.getElementById("rewardOverlay").classList.replace("overlay-visible", "overlay-hidden");
                    const rImg = document.getElementById("rewardImage");
                    rImg.classList.remove("anim-reveal"); 
                    rImg.classList.remove("anim-reveal-clean");
                    rImg.classList.remove("anim-star-epic");

                    if (this.tempCapsule) { this.tempCapsule.dispose(); this.tempCapsule = null; }
                    setTimeout(() => {
                         rImg.src = "";
                         this.pendingRewardImage = null; 
                         // ★★★ 關鍵修改：只有當膠囊數量為 0 時，且按下再玩一次，才會出現補蛋按鈕 ★★★
                         if (this.capsules.length === 0) refillBtn.style.display = "block";
                    }, 500);
                    if (this.chuteDoor && this.chuteDoor.position.y < -6.1) {
                        BABYLON.Animation.CreateAndStartAnimation("closeDoor", this.chuteDoor, "position.y", 30, 15, this.chuteDoor.position.y, -6.1, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    }
                });

                this.scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh) {
                        let mesh = pointerInfo.pickInfo.pickedMesh;
                        while(mesh) {
                            if (mesh.name === "knobRoot" || mesh.parent?.name === "knobRoot") {
                                this.spin();
                                break;
                            }
                            mesh = mesh.parent;
                        }
                    }
                });
            }
            
            clearCapsules() {
                this.capsules.forEach(c => {
                    if(c.physicsImpostor) c.physicsImpostor.dispose();
                    c.dispose();
                });
                this.capsules = [];
            }

            refillCapsules() {
                const modeName = GAME_MODES[this.currentMode].name;
                this.showSystemMessage(`填入${modeName}...`);
                
                this.audio.playOpenSound();
                setTimeout(() => {
                    if (this.capsules.length > 0) this.clearCapsules(); 
                    this.createCapsules(this.shadowGen);
                    setTimeout(() => { 
                        const sysMsg = document.getElementById("systemMessage");
                        sysMsg.style.opacity = "0"; 
                        setTimeout(() => { sysMsg.innerText = ""; }, 600);
                    }, 1000); 
                }, 500);
            }

            getReward() {
                let data = GAME_MODES[this.currentMode].data;
                
                if (this.history.size >= Math.min(this.maxHistory, data.length)) this.history.clear();
                let available = data.filter(p => !this.history.has(p.name));
                if (available.length === 0) { this.history.clear(); available = data; }
                const pick = available[Math.floor(Math.random() * available.length)];
                this.history.add(pick.name);
                return pick;
            }

            showSystemMessage(text) {
                const el = document.getElementById("systemMessage");
                el.innerText = text; el.style.opacity = 1;
            }

            spin() {
                if (this.isSpinning || this.capsules.length === 0) return;
                this.isSpinning = true;

                const reward = this.getReward();
                this.pendingRewardImage = new Image();
                this.pendingRewardImage.src = reward.url;

                this.audio.ctx.resume(); this.audio.playSpinSound();
                if (navigator.vibrate) navigator.vibrate([100, 50, 100]);

                const knobAnim = new BABYLON.Animation("knobSpin", "rotation.z", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                knobAnim.setKeys([{frame: 0, value: 0}, {frame: 60, value: -Math.PI * 2}]); 
                this.scene.beginDirectAnimation(this.knob, [knobAnim], 0, 60, false);

                this.capsules.forEach(cap => {
                    if (cap.physicsImpostor) {
                        const impulse = new BABYLON.Vector3((Math.random()-0.5)*20, 20+Math.random()*10, (Math.random()-0.5)*20);
                        cap.physicsImpostor.applyImpulse(impulse, cap.getAbsolutePosition());
                    }
                });

                const idx = Math.floor(Math.random() * this.capsules.length);
                const removedCap = this.capsules[idx];
                const capsuleData = removedCap.metadata; 

                this.capsules.splice(idx, 1);
                BABYLON.Animation.CreateAndStartAnimation("fadeOutCap", removedCap, "visibility", 60, 30, 1, 0, 0);
                setTimeout(() => removedCap.dispose(), 500);

                setTimeout(() => {
                    BABYLON.Animation.CreateAndStartAnimation("openDoor", this.chuteDoor, "position.y", 60, 30, -6.1, -8.5, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT, new BABYLON.BackEase(0.3));
                    BABYLON.Animation.CreateAndStartAnimation("lightUp", this.chuteLight, "intensity", 60, 20, 0, 8, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    if (this.chuteParticles) this.chuteParticles.start();

                    setTimeout(() => {
                        this.playExitAnimation(reward, capsuleData);
                        
                        setTimeout(() => {
                            if (this.chuteParticles) this.chuteParticles.stop();
                            BABYLON.Animation.CreateAndStartAnimation("lightDown", this.chuteLight, "intensity", 60, 30, 8, 0, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                            setTimeout(() => {
                                BABYLON.Animation.CreateAndStartAnimation("closeDoor", this.chuteDoor, "position.y", 60, 30, this.chuteDoor.position.y, -6.1, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT, new BABYLON.CubicEase());
                            }, 1200);
                        }, 500);
                    }, 400);
                }, 1200);
            }

            playExitAnimation(reward, capsuleData) {
                const parent = new BABYLON.TransformNode("presentCap", this.scene);
                parent.position = new BABYLON.Vector3(0, -6.2, -5); parent.scaling.setAll(0.1);

                const config = GAME_MODES[this.currentMode].capsule;

                let topColor = new BABYLON.Color3(0.9, 0.05, 0.1); 
                let botColor = BABYLON.Color3.White();
                
                if (capsuleData && capsuleData.topColor) {
                    topColor = capsuleData.topColor;
                    botColor = capsuleData.botColor;
                }

                const topMat = new BABYLON.PBRMaterial("pTop", this.scene);
                topMat.albedoColor = topColor; 
                topMat.metallic = config.exitMat.metallic;   
                topMat.roughness = config.exitMat.roughness;  
                topMat.environmentIntensity = config.exitMat.envIntensity; 
                topMat.backFaceCulling = false;
                
                const botMat = new BABYLON.PBRMaterial("pBot", this.scene);
                botMat.albedoColor = botColor; 
                botMat.metallic = config.exitMat.metallic; 
                botMat.roughness = config.exitMat.roughness; 
                botMat.environmentIntensity = config.exitMat.envIntensity; 
                botMat.backFaceCulling = false;

                const top = BABYLON.MeshBuilder.CreateSphere("top", {diameter: 2.5, slice: 0.5}, this.scene);
                top.material = topMat; top.parent = parent;
                const bottom = BABYLON.MeshBuilder.CreateSphere("bottom", {diameter: 2.5, slice: 0.5}, this.scene);
                bottom.rotation.x = Math.PI; bottom.material = botMat; bottom.parent = parent;

                let ring, btn;
                if (config.hasDetails) {
                    const blackMat = new BABYLON.PBRMaterial("pBlack", this.scene);
                    blackMat.albedoColor = new BABYLON.Color3(0.1, 0.1, 0.1); blackMat.metallic = 0.1; blackMat.roughness = 0.3;
                    
                    ring = BABYLON.MeshBuilder.CreateTorus("ring", {diameter: 2.5, thickness: 0.15}, this.scene);
                    ring.material = blackMat; ring.parent = parent;
                    
                    btn = BABYLON.MeshBuilder.CreateCylinder("btn", {diameter: 0.6, height: 0.2}, this.scene);
                    btn.rotation.x = Math.PI/2; btn.position.z = 1.2; btn.material = botMat; btn.parent = parent;
                    
                    ring.renderingGroupId = 1; btn.renderingGroupId = 1;
                }
                
                top.renderingGroupId = 1; bottom.renderingGroupId = 1;

                const ballLight = new BABYLON.PointLight("ballLight", new BABYLON.Vector3(0,0,0), this.scene);
                ballLight.parent = parent; 
                ballLight.intensity = 0; 
                ballLight.diffuse = new BABYLON.Color3(1, 0.8, 0.4);

                this.tempCapsule = parent;
                const targetPos = new BABYLON.Vector3(0, 3.3, -12);
                
                BABYLON.Animation.CreateAndStartAnimation("flyPos", parent, "position", 60, 90, parent.position, targetPos, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT, new BABYLON.BezierCurveEase(0.3, 0, 0, 1));
                BABYLON.Animation.CreateAndStartAnimation("flyScale", parent, "scaling", 60, 90, parent.scaling, new BABYLON.Vector3(2.5, 2.5, 2.5), BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                BABYLON.Animation.CreateAndStartAnimation("flyRot", parent, "rotation", 60, 90, new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, Math.PI * 4, 0), BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);

                setTimeout(() => {
                    const shakeAnim = new BABYLON.Animation("shake", "rotation.z", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    const shakeKeys = []; for(let i=0; i<=20; i++) shakeKeys.push({ frame: i, value: Math.sin(i) * 0.2 });
                    shakeAnim.setKeys(shakeKeys);
                    
                    const lightAnim = new BABYLON.Animation("glow", "intensity", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    lightAnim.setKeys([{frame: 0, value: 0}, {frame: 20, value: 1.0}]);

                    this.scene.beginDirectAnimation(parent, [shakeAnim], 0, 20, true); 
                    this.scene.beginDirectAnimation(ballLight, [lightAnim], 0, 20, false);
                    this.audio.playOsc('sine', 300, 0, 0.7, 0.3, 900);

                    setTimeout(() => {
                        this.scene.stopAnimation(parent);
                        parent.rotation.z = 0;
                        this.audio.playOpenSound();
                        
                        if (ring) ring.isVisible = false; 
                        if (btn) btn.isVisible = false;

                        const ease = new BABYLON.CubicEase();
                        ease.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEOUT);

                        BABYLON.Animation.CreateAndStartAnimation("openTop", top, "position.y", 60, 30, 0, 2.5, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT, ease);
                        BABYLON.Animation.CreateAndStartAnimation("openBot", bottom, "position.y", 60, 30, 0, -2.5, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT, ease);

                        document.getElementById("flashScreen").classList.add("flash-active");
                        setTimeout(() => document.getElementById("flashScreen").classList.remove("flash-active"), 800);
                        
                        const show = () => {
                            if (this.hasShownReward) return;
                            this.hasShownReward = true;
                            this.showReward(reward);
                        };

                        this.hasShownReward = false; 

                        if (this.pendingRewardImage) {
                            if (this.pendingRewardImage.complete) {
                                show();
                            } else {
                                this.pendingRewardImage.onload = show;
                                this.pendingRewardImage.onerror = show;
                                setTimeout(show, 2000); 
                            }
                        } else {
                            show();
                        }

                        this.isSpinning = false;
                    }, 800);
                }, 1500);
            }

            showReward(reward) {
                const overlay = document.getElementById("rewardOverlay");
                const img = document.getElementById("rewardImage");
                const name = document.getElementById("rewardName");
                const enNameEl = document.getElementById("englishName");

                img.src = reward.url;
                
                const config = GAME_MODES[this.currentMode].ui;

                if (config.showText) {
                    name.style.display = 'block';
                    enNameEl.style.display = 'block';
                    name.innerText = reward.name.split(' ')[0]; 
                    const match = reward.name.match(/\((.*?)\)/);
                    enNameEl.innerText = match ? match[1].toUpperCase() : "POKEMON";
                } else {
                    name.style.display = 'none';      
                    enNameEl.style.display = 'none'; 
                }

                img.className = "relative w-full h-full object-contain"; 
                img.classList.add(config.animClass);

                overlay.classList.replace("overlay-hidden", "overlay-visible");
                this.audio.playWinSound();
                if (navigator.vibrate) navigator.vibrate(500);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new GachaGame();
        });

    </script>
</body>
</html>